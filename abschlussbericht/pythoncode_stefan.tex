\subsection{denkdirwasaus1}
 \label{subsec:denkdirwasaus1}

\begin{itemize}
 \item Sequenzielle Abarbeitung des Dokuments
\end{itemize}

Die zunächst unformatierten Daten der Datei "{}personendaten2.txt"{}, werden Zeilenweise extrahiert. Diese sind recht unhandlich und weisen Längen von bis zu 18760 Zeichen auf. Danach folgt die statische Unterteilung, durch die Trennzeichen: "{}.-"{}, in die jeweiligen Datensätze. Die Funktion "{}get\_data\_sets"{} ist dafür zuständig. Nun werden die Sets einzeln eingelesen. Zur besseren Lesbarkeit der endgültigen Daten werden alle Attribute, welche im folgenden gefunden werden, in ein geordnetes Dictionary ("{}OrderedDict()"{} aus der Klasse "{}collections"{}) geschrieben.

Nun wird als erstes das Set in 2 listen durch den Begrenzer '{}:'{} geteilt. Dies geschieht in der Funktion "{}getting\_name"{}. Jener Teil, der vor dem Begrenzer steht, dient der Namenszuweisung. Weiter wird durch "{}get\_surname"{} und "{}get\_prename"{} der Nachname bzw. der Vorname ermittelt. Diese sind wieder durch '{},'{} voneinander getrennt. Bsp: "{}Abb, Edmund: [...]"{}. Zum Schluss werden die gefundenen Attribute in das Dictionary gespeichert.

Die Funktion "{}get\_birth\_place\_and\_academic\_title"{} ermittelt den Geburtsort sowie die erlangten akademischen Titel. Jene befinden sich in der Sequenz, die mit "{}:"{} eingeleitet und "{}-{}-"{} beendet wird. Anschließend wird die Funktion "{}check\_date"{} aufgerufen. Hier wird nach der Kombination von mindestens einer Ziffer, einem Punkt,mindestens einer Ziffer,einem Punkt gefolgt von mindestens zwei Ziffern gesucht. Dies ist als regulärer Ausdruck formuliert: "{}[0-9]+\textbackslash.[0-9]+\textbackslash.[0-9][0-9]+"{}. Wird ein solches Datum gefunden, gehen wir davon aus, dass es sich um das Geburtsdatum der Person handelt. Der restliche String wird an die aufrufende Funktion zurückgegeben.
Mit der Funktion "{}get\_academic\_title"{} wird nun nach einem potentiellen akademischen Titel gesucht. Das geschieht wieder mit einem regulärem Ausdruck der Form: "{}(stud\textbackslash.)+|(dr\textbackslash.)+"{}. Wird ein solcher gefunden geht das Tool davon aus, dass die Spezifikation des akademischen Titels (z.B. Chirurg) mit einem "{},"{} beendet wird. Falls dies nicht er Fall ist wird nach dem Wort "{}aus"{} gesucht, welches als Einleitung für den Ort angenommen wird und stellvertretend den Informationsabschnitt beendet. Bsp: "{}[...]: stud. Philol., geb. 9.8.1857 in Bautzen-{}-"{}.
Als nächstes werden Bindewörter wie "{}geb"{}, "{}aus"{}, "{}in"{} aus dem String entfernt. Dieser wird mit einer Liste der Leipziger Ortsteile verglichen ("{}liste\_leipziger\_vororte\_clean"{}). Wird ein solcher erkannt nimmt das Programm im folgenden als Geburtsort Leipzig an. Dies soll mögliche Komplikationen beim Abgleich mit der Geodatenbank verhindern, da Leipziger Vororte zwar geschildert, andere Städte aber ohne weitere Unterteilung genannt werden. Falls es sich nicht um einen Vorort von Leipzig handelt, wird der String an die Methode "{}Location.getLocation"{} übergeben (siehe Ortsbestimmung). Liefert der Aufruf ein Ergebnis, wird dieses im Dictionary abgelegt.

Die folgende Funktion "{}get\_certificate"{} sucht nach den Zertifikaten, welche mit "{}-{}-"{} vom restlichen String getrennt sind. Wird das Programm fündig behandelt es jeden, durch '{},'{} abgetrennten, Abschnitt wie folgt:
Es wird nach dem Datum mit dem regulären Ausdruck: "{}.*(\textbackslash{}d$\{4\}$([/]\textbackslash{}d$\{2\}$)*).*"{} gesucht. Danach wird die Stadt ermittelt, wo das Zertifikat erworben wurde. Hierzu wird das vorletzte Wort aus dem String genommen und überprüft, ob es korrekt ist. Folgende Syntax ist hier sehr häufig anzutreffen: [Typ] [Institution] [Ort] [Jahr] z.b. "{}[...] Abgangszeugnis Universitätsgericht Leipzig 1842"{}. Somit erwies sich dieses Muster als sehr Treffsicher. Zum Schluss wird der (Zeugnis-) Typ ermittelt, indem einfach nach "{}zeugnis"{}, "{}diplom"{}, ... im String gesucht wird. Anschließend werden alle gefundenen Attribute in einer Liste gespeichert und jene in das Dictionary abgelegt.

Wurden alle Werte in allen Sets gelesen werden diese mittels der "{}json.dump"{} Methode in der "{}to\_json"{}-Funktion in ein JSON-File geschrieben.
