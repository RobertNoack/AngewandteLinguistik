\subsection{Parsing der Daten}
 \label{subsec:Parsing der Daten}


Die zunächst unformatierten Daten der Datei "{}personendaten2.txt"{}, werden Zeilenweise extrahiert. Diese sind recht unhandlich und weisen Längen von bis zu 18760 Zeichen auf. Die Funktion "{}check\_for\_begin"{} sucht nach dem jeweils ersten Datensatz jeder Zeile und setzt die Startpositionen an die gefundenen Stelle. Danach folgt die statische Unterteilung, durch die Trennzeichen: "{}.-"{} in die jeweiligen Datensätze. Dafür ist die Funktion "{}get\_data\_sets"{} zuständig, in der die Sets einzeln eingelesen werden. Zur besseren Lesbarkeit der endgültigen Daten werden alle Attribute, welche im Folgenden gefunden werden, in ein geordnetes Dictionary ("{}OrderedDict()"{} aus der Klasse "{}collections"{}) geschrieben.

Nun wird zunächst das Set durch den Begrenzer '{}:'{} in zwei Listen geteilt. Dies geschieht in der Funktion "{}get\_name"{}. Der Teil vor dem Begrenzer, wird zur Namenszuweisung verwendet. Weiter wird durch "{}get\_surname"{} und "{}get\_prename"{} der Nachname bzw. der Vorname ermittelt. Diese sind lediglich durch '{},'{} voneinander getrennt (Bsp: "{}Abb, Edmund: [...]"{}). Zum Schluss werden die gefundenen Attribute im Dictionary gespeichert.

Im Anschluss wird überprüft, ob nach dem Namensbereich persönliche Informationen folgen. Diese befinden sich in der Sequenz, die mit "{}:"{} eingeleitet und "{}-{}-"{} beendet wird. Durch Funktion "{}get\_birth\_place\_and\_academic\_title"{} werden die Informationen zur Herkunft sowie den erlangten akademischen Titeln ermittelt. Anschließend wird die Funktion "{}check\_for\_date"{} aufgerufen. Hier wird nach dem Regulären Ausdruck für ein Datum gesucht ("{}[0-9]+\textbackslash.[0-9]+\textbackslash.[0-9][0-9]+"{}). Wird ein solches Datum gefunden, gehen wir davon aus, dass es sich um das Geburtsdatum der Person handelt. Der restliche String wird an die aufrufende Funktion zurückgegeben.

Mit der Funktion "{}get\_academic\_title"{} wird nun nach einem potentiellen akademischen Titel gesucht. Das geschieht wieder mit einem regulärem Ausdruck der Form: "{}(stud\textbackslash.)+|(dr\textbackslash.)+"{}. Wird ein solcher gefunden geht das Tool davon aus, dass die Spezifikation des akademischen Titels (z.B. Chirurg) mit einem "{},"{} beendet wird. Falls dies nicht er Fall ist wird nach dem Wort "{}aus"{} gesucht, welches als Einleitung für den Ort angenommen wird und stellvertretend den Informationsabschnitt beendet (Bsp: "{}[...]: stud. Philol., geb. 9.8.1857 in Bautzen-{}-"{}).

Als nächstes werden Bindewörter wie "{}geb."{}, "{}aus"{}, "{}in"{} aus dem String entfernt. Dieser wird anschließend mit einer Liste der Leipziger Ortsteile verglichen ("{}liste\_leipziger\_vororte\_clean"{}). Wird ein solcher erkannt, nimmt das Programm im folgenden als Geburtsort Leipzig an. Dies soll mögliche Komplikationen beim Abgleich mit der Geodatenbank verhindern, da Leipziger Vororte zwar geschildert, andere Städte aber ohne weitere Unterteilung genannt werden. Falls es sich nicht um einen Vorort von Leipzig handelt, wird der String an die Methode "{}Location.getLocation"{} übergeben (siehe Ortsbestimmung). Liefert der Aufruf ein Ergebnis, wird dieses im Dictionary abgelegt.

Zum Schluss sucht die Funktion "{}get\_certificate"{} nach den Zertifikaten, welche mit "{}-{}-"{} vom restlichen String getrennt sind. Wird das Programm fündig, behandelt es jeden, durch '{},'{} abgetrennten Abschnitt wie folgt:
Zunächst wird nach dem Datum mit dem regulären Ausdruck: "{}.*(\textbackslash{}d$\{4\}$([/]\textbackslash{}d$\{2\}$)*).*"{} gesucht. Danach wird die Stadt ermittelt, in der das Zertifikat erworben wurde. Hierzu wird das vorletzte Wort aus dem String genommen und überprüft, ob es korrekt ist. Folgende Syntax ist hier sehr häufig anzutreffen: [Typ] [Institution] [Ort] [Jahr] (z.b. "{}[...] Abgangszeugnis Universitätsgericht Leipzig 1842"{}). Somit erweist sich dieses Muster als sehr treffsicher. Zum Schluss wird der Dokumententyp ermittelt, indem nach den Zeichenketten "{}zeugnis"{}, "{}diplom"{}, etc. im String gesucht wird. Anschließend werden alle gefundenen Attribute in einer Liste gespeichert und in das Dictionary abgelegt.

Wurden alle Werte in allen Sets gelesen werden diese mittels der "{}json.dump"{} Methode in der "{}to\_json"{}-Funktion in ein JSON-File geschrieben.
